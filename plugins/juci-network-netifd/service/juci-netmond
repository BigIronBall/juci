#!/usr/bin/lua 

-- Author: Martin K. Schr√∂der <mkschreder.uk@gmail.com>

require "ubus"
require "uloop"
require("JUCI"); 

local console = {
	log = function(msg)
		local fd = io.open("/dev/console", "w"); 
		fd:write("juci-networkd: "..(msg or "").."\n"); 
		fd:close();
	end
}; 

function find(tbl, cb) 
	for _,v in pairs(tbl) do 
		if cb(v) then return v; end
	end
	return nil; 
end

function host_alive(ip)
	local alive = juci.shell("ping -c 1 -W 4 %s | grep 'packets received' | awk '{ if($1 == $4) { print 1 } else { print 0 } }'", ip); 
	if alive:match("1") then 
		return true; 
	else 
		return false; 
	end
end

local conn = ubus.connect()
if not conn then
	error("Failed to connect to ubus")
end

local Netmon = {
	clients = {}
}; 

function Netmon:new(o)
	o = o or {}; 
	setmetatable(o, self); 
	self.__index = self; 
	return o; 
end 

function Netmon:update_clients()
	-- parse out dhcp information 
	function read_dhcp_info()
		local dhcp = {}; 
		local dhcp_leases = io.open("/var/dhcp.leases", "r"); 
		local line = dhcp_leases:read("*l"); 
		while line do
			local leasetime, macaddr, ipaddr, hostname = line:match("([^%s]+)%s+([^%s]+)%s+([^%s]+)%s+([^%s]+)"); 
			if macaddr then 
				dhcp[macaddr] = {
					leasetime = leasetime, 
					ipaddr = ipaddr, 
					hostname = hostname, 
					macaddr = macaddr
				}; 
			end 
			line = dhcp_leases:read("*l"); 
		end
		dhcp_leases:close(); 
		return dhcp; 
	end
	
	function read_arp_info()
		local arp = {}; 
		local proc_arp = io.open("/proc/net/arp", "r"); 
		-- skip first line with headers
		proc_arp:read("*l"); 
		
		local line = proc_arp:read("*l"); 
		while line do 
			local ip, hwtype, flags, macaddr, mask, device = line:match("([^%s]+)%s+([^%s]+)%s+([^%s]+)%s+([^%s]+)%s+([^%s]+)%s+([^%s]+)"); 
			if ip and macaddr and device then 
				arp[macaddr] = {
					ipaddr = ip, 
					macaddr = macaddr, 
					device = device
				}; 
			end
			line = proc_arp:read("*l"); 
		end
		proc_arp:close(); 
		return arp; 
	end 
	
	function read_clients()
		local result = read_arp_info(); -- arp info is usually better for getting clients that are actually connected
		local dhcp_leases = read_dhcp_info(); 
		
		-- combine fields
		for mac,dhcp in pairs(dhcp_leases) do 
			local r = result[mac]; 
			if r then 
				for k,v in pairs(dhcp) do 
					r[k] = v; 
				end
			end
		end
		return result; 
	end
	
	-- check which clients have connected and which ones have disconnected
	local clients = read_clients(); 
	local online_clients = {}; 
	local offline_clients = self.clients; 
	
	for mac,cl in pairs(clients) do 
		local existing = offline_clients[mac]; 
		if existing then 
			if host_alive(existing.ipaddr) then 
				-- client was known before and is still online
				offline_clients[mac] = nil; 
				online_clients[mac] = cl; 
			else 
				-- client was known before but has disconnected
				-- skip and handle later
			end
		else 
			if host_alive(cl.ipaddr) then 
				-- client was not known before and is now online
				online_clients[mac] = cl; 
				conn:send("juci.netmond.client.up", cl); 
			else 
				-- do nothing
			end
		end
	end
	
	-- the clients that are left in the old list are all offline then
	for mac,cl in pairs(offline_clients) do
		conn:send("juci.netmond.client.down", cl); 
	end
	
	-- now we can replace our list of clients with the new list of online clients that we have generated
	self.clients = online_clients; 
end

local netmon = Netmon:new(); 

while true do 
	netmon:update_clients();
	juci.shell("sleep 5"); 
end 

uloop.init()

local objects = {
	["juci.netmond"] = {
		clients = {
			function(req)
				netmon:get_clients(); 
				conn:reply(req, { clients = netmon:get_connected_clients() }); 
			end, {}
		},
	}
}

conn:add(objects); 

uloop.run()
